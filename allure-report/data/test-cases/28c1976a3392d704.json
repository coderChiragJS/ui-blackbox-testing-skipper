{"uid":"28c1976a3392d704","name":"should handle invalid credentials gracefully","historyId":"7a8695265d68bf2b83b53185509aa3f3","time":{"start":1756360797048,"stop":1756360814545,"duration":17497},"status":"broken","statusMessage":"write EPIPE","statusTrace":"Error: write EPIPE\n    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n    at writeGeneric (node:internal/stream_base_commons:152:3)\n    at Socket._writeGeneric (node:net:958:11)\n    at Socket._write (node:net:970:8)\n    at writeOrBuffer (node:internal/streams/writable:572:12)\n    at _write (node:internal/streams/writable:501:10)\n    at Writable.write (node:internal/streams/writable:510:10)\n    at console.value (node:internal/console/constructor:303:16)\n    at console.warn (node:internal/console/constructor:383:26)\n    at file:///Users/chiragtankwal/projects/ui-test-blackbox/node_modules/@wdio/logger/build/index.js:145:7","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":5,"retriesStatusChange":false,"beforeStages":[],"testStage":{"status":"broken","statusMessage":"write EPIPE","statusTrace":"Error: write EPIPE\n    at afterWriteDispatched (node:internal/stream_base_commons:161:15)\n    at writeGeneric (node:internal/stream_base_commons:152:3)\n    at Socket._writeGeneric (node:net:958:11)\n    at Socket._write (node:net:970:8)\n    at writeOrBuffer (node:internal/streams/writable:572:12)\n    at _write (node:internal/streams/writable:501:10)\n    at Writable.write (node:internal/streams/writable:510:10)\n    at console.value (node:internal/console/constructor:303:16)\n    at console.warn (node:internal/console/constructor:383:26)\n    at file:///Users/chiragtankwal/projects/ui-test-blackbox/node_modules/@wdio/logger/build/index.js:145:7","steps":[],"attachments":[{"uid":"331e725201a9c8b8","name":"Screenshot","source":"331e725201a9c8b8.png","type":"image/png","size":1100287},{"uid":"ca944c3c3e35e527","name":"Screenshot","source":"ca944c3c3e35e527.png","type":"image/png","size":1100287},{"uid":"214523a2814cf42","name":"Screenshot","source":"214523a2814cf42.png","type":"image/png","size":1100287},{"uid":"5928c5f0ae811800","name":"Screenshot","source":"5928c5f0ae811800.png","type":"image/png","size":1100287},{"uid":"a542137f26f80029","name":"Screenshot","source":"a542137f26f80029.png","type":"image/png","size":1100281}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":5,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"language","value":"javascript"},{"name":"framework","value":"wdio"},{"name":"package","value":".Users.chiragtankwal.projects.ui-test-blackbox.test.specs.regression.login.regression.test.js"},{"name":"thread","value":"0-0"},{"name":"suite","value":"Login Regression Tests"},{"name":"feature","value":"Login Regression Tests"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"device","value":"skipper11-2025-08-25-debug.apk"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[{"uid":"90e3ec29ebab7e63","status":"broken","statusDetails":"waitUntil condition failed with the following reason: WebDriverError: Method is not implemented when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"","time":{"start":1756360778292,"stop":1756360797045,"duration":18753}},{"uid":"b0e70e0712e10226","status":"broken","statusDetails":"waitUntil condition failed with the following reason: WebDriverError: Method is not implemented when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"","time":{"start":1756360759852,"stop":1756360778288,"duration":18436}},{"uid":"77a57cbc213d6d47","status":"broken","statusDetails":"WebDriverError: An unknown server-side error occurred while processing the command. Original error: 'POST /element' cannot be proxied to UiAutomator2 server because the instrumentation process is not running (probably crashed). Check the server log and/or the logcat output for more details when running \"element\" with method \"POST\" and args \"{\"using\":\"accessibility id\",\"value\":\"Login\"}\"","time":{"start":1756359438524,"stop":1756359440064,"duration":1540}},{"uid":"57de0b50e38448ab","status":"broken","statusDetails":"WebDriverError: An unknown server-side error occurred while processing the command. Original error: 'POST /element' cannot be proxied to UiAutomator2 server because the instrumentation process is not running (probably crashed). Check the server log and/or the logcat output for more details when running \"element\" with method \"POST\" and args \"{\"using\":\"accessibility id\",\"value\":\"Login\"}\"","time":{"start":1756359437006,"stop":1756359438523,"duration":1517}},{"uid":"87ad31ba9b196348","status":"broken","statusDetails":"waitUntil condition failed with the following reason: WebDriverError: An unknown server-side error occurred while processing the command. Original error: 'GET /element/00000000-0000-0041-0000-004200000004/attribute/displayed' cannot be proxied to UiAutomator2 server because the instrumentation process is not running (probably crashed). Check the server log and/or the logcat output for more details when running \"element/00000000-0000-0041-0000-004200000004/displayed\" with method \"GET\"","time":{"start":1756359418710,"stop":1756359437001,"duration":18291}}],"categories":[{"name":"Test defects","matchedStatuses":[]}],"tags":[]},"source":"28c1976a3392d704.json","parameterValues":["skipper11-2025-08-25-debug.apk"]}